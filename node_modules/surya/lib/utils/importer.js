"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.importProfiler = importProfiler;
exports.resolveImportPath = resolveImportPath;
var fs = require('fs');
var path = require('path');
var parser = require('@solidity-parser/parser');

/**
 * Given a list of Solidity files, returns a list of imports from those files and all files imported by those files.
 * This function throws an error if a path is resolved to a higher level than projectDir and if it's not a .sol file.
 *
 * @param {Array}   files          - Solidity files to parse for imports.
 * @param {string}  projectDir     - The highest level directory accessible.
 * @param {Set}     importedFiles  - Files already parsed.
 * @returns {Array} importPaths    - A list of importPaths.
 */
function importProfiler(files) {
  var projectDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.cwd();
  var importedFiles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();

  var _loop = function _loop(_file) {
    // Check for a valid Solidity file.
    _file = path.resolve(projectDir, _file);
    if (_file.indexOf(projectDir) !== 0 || !_file.endsWith('.sol')) {
      throw new Error('Invalid import path: ' + _file);
    }
    var content = void 0;
    try {
      content = fs.readFileSync(_file, 'utf-8');
    } catch (e) {
      if (e.code === 'EISDIR') {
        console.error('Skipping directory: ' + _file);
        return {
          v: importedFiles
        }; // Empty Set
      } else {
        throw e;
      }
    }
    // Add the valid Solidity file to the set of importedFiles.
    importedFiles.add(_file);
    var ast = function () {
      try {
        return parser.parse(content, { tolerant: true });
      } catch (err) {
        console.error('Error found while parsing file: ' + _file + '\n');
        throw err;
      }
    }();

    // Create an array to hold the imported files.
    var newFiles = [];
    parser.visit(ast, {
      ImportDirective: function ImportDirective(node) {
        var newFile = resolveImportPath(_file, node.path, projectDir);
        if (!importedFiles.has(newFile)) newFiles.push(newFile);
      }
    });
    // Recursively process the array of imported files.
    importProfiler(newFiles, projectDir, importedFiles);
    file = _file;
  };

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = files[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var file = _step.value;

      var _ret = _loop(file);

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }
    // Convert the set to an array for easy consumption.
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var importedFilesArray = Array.from(importedFiles);
  return importedFilesArray;
}

/**
 * Takes a filepath, an import path found within it, and finds the corresponding source code file.
 * Throws an error if the resolved path is not a file.
 *
 * @param {string} baseFilePath      - The base file path.
 * @param {string} importedFilePath  - The imported file path.
 * @param {string} projectDir        - The top-most directory to search in.
 * @returns {string} resolvedPath   - The resolved file path.
 */
function resolveImportPath(baseFilePath, importedFilePath) {
  var projectDir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.cwd();

  // Split the project directory path.
  var topmostDirArray = projectDir.split(path.sep);
  var resolvedPath = void 0;
  var baseDirPath = path.dirname(baseFilePath);

  // If it's a relative or absolute path:
  if (importedFilePath.slice(0, 1) === '.' || importedFilePath.slice(0, 1) === '/') {
    resolvedPath = path.resolve(baseDirPath, importedFilePath);
  } else {
    // It's most likely a special case using a remapping to node_modules directory.
    var currentDir = path.resolve(baseDirPath, '..');
    var currentDirArray = baseDirPath.split(path.sep);
    var currentDirName = currentDirArray.pop();
    var nodeModulesDir = '';

    while (!fs.readdirSync(currentDir).includes('node_modules') && !nodeModulesDir) {
      if (topmostDirArray.length >= currentDirArray.length) {
        throw new Error('Import statement seems to be a Truffle "node_modules remapping," but no \'node_modules\' directory could be found.');
      }
      currentDirName = currentDirArray.pop();
      currentDir = path.resolve(currentDir, '..');
    }

    // We've found the directory containing node_modules.
    nodeModulesDir = path.join(currentDir, 'node_modules');
    resolvedPath = path.join(nodeModulesDir, importedFilePath);
  }

  // Verify that the resolved path is actually a file.
  if (!fs.existsSync(resolvedPath) || !fs.statSync(resolvedPath).isFile()) {
    throw new Error('Import path not resolved to a file: ' + resolvedPath);
  }

  return resolvedPath;
}